* qdfoxJSON.PRG
* Quick & Dirty Foxpro JSON parser
*
* Author  : Victor Espina
* Last upd: January 2012
*
* Usage:
* SET PROCEDURE TO qdfoxJSON ADDITIVE
*
* Functions:
* - string = JSONEncode(object | array)
* - object = JSONDecode(string)
* - object = JSONObject([string])
* - JSONDeclareSchema(jsonSchemaString) [1]
*
* JSONObject Interface:
* string Schema
* (void) Add(string propertyName, variant propertyValue)
* (object) Add(string propertyName, arrayValue)
* (object) Add(string propertyName, string jsonString)
* (object) addArray(string propertyName)
* (string) ToJSON()
* (void) Parse(string jsonString)
* (void) Import(object | alias)
* (void) Export(object | alias)
*
* Examples:
* 1. Encoding an object to a JSON string using JSONObject (this is the preferred method):
*      myObject = JSONObject()
*      myObject.add("Name","foo")
*      myObject.add("Age",40)
*      jsonString = myObject.ToJSON()
*
* 2. Encoding an object using JSONEncode() function:
*      myObject = CREATEOBJECT("Empty")
*      ADDPROPERTY("Name","foo")
*      ADDPROPERTY("Age",40)
*      jsonString = JSONEncode(myObject)
*
* 3. Parsing a JSON string using JSONObject (this is the preferred method):
*      myObject = JSONObject(jsonString)
*
* 4. Parsing a JSON string using JSONDecode() function:
*      myObject = JSONDecode(jsonString)
*
* 5. Creating a JSONObject manually:
*      myObject = JSONObject("{name:'Foo',age:40}")
*      ?myObject.Name --> 'Foo'
*      ?myObject.Age --> 40
*      myObject.Add("Sex","Male")
*      ?myObject.Sex --> 'Male'
*
*      myObject.addArray("Hobbies","['Read','Trekking','Football']")
*      ?myObject.Hobbies.Count --> 3
*      ?myObject.Hobbies[2] --> 'Trekking'
*
*      myObject.Add("Car","{Maker:'Hyundai',Model:'Accent',Year:2007}")
*      ?myObject.Car.Maker --> "Hyundai"
*      myObject.Car.Add("Engine","V4 1.3 lts")
*      ?myObject.Car.Engine --> 'V4 1.3 lts'
*
* 6. Creating a JSONObject from a declared schema: [1]
*      JSONDeclareSchema("User",;
*          "{loginName:string,"+;
*          " fullName:string,"+;
*          " password:string,"+;
*          " lastLogin:datetime}")
*      myObject = JSONObject("schema:User")
*      ?myObject.Schema --> User
*      myObject.loginName = "vespina"
*      
* 7. Create a JSON object and import its values from a table row:
*      JSONDeclareSchema("Customer","{id:numeric,name:string,balance:numeric,active:boolean}")
*      SELECT customers
*      LOCATE FOR id = 25
*      oCustomer = JSONObject("schema:Customer")
*      oCustomer.Import("customers")
*      ?oCustomer.Id --> 25
*
* 8. Update a data record from a JSON object:
*      oCustomer = JSONObject("schema:Customer")
*      oCUstomer.Id = 25
*      oCUstomer.Name = "VICTOR ESPINA"
*      oCustomer.Balance = 1244.23
*      oCustomer.Active = .T.
*      SELECT customers
*      APPEND BLANK
*      oCustomer.Export("customers")
*      ?id --> 25
*      ?name --> 'VICTOR ESPINA'
*
* NOTES:
* [1] JSON schemas is a personal adaptation of the JSON syntax and
*     it is not supported by JSON.org standards.  The idea is to 
*     declare a object "schema" or data structure and then use it
*     to create empty instances that follows the schema properties.
*
*     This allow us, i.e., to declare a "User" schema and use it every time 
*     we need to handle user's data. This way, if we later need to add
*     a new property to User objects, all we have to do is to change
*     the schema and the new property will be available to the entire
*     app. Is important to understand that this is not supossed to 
*     substitute your custom classes... is more like to have the ability
*     to declare and use data structures to represent complex data.
*
*     A schema definition string contains one or more "property:type" pairs
*     separated with comma and enclosed within curly brackets:
*
*     {name:string,fullName:string,age:numeric,dateOfBirth:datetime}
*
*     The recognized data types are:
*      string
*      numeric
*      boolean
*      date
*      datetime
*      array (parsed as a Collection instance)
*
*     You can also declare object properties, by following the same rules:
*   
*     {name:string,fullName:string,personalInfo:{age:numeric,dob:date},password:string}
*
*     this will create an object with the following interface:
*
*     object
*       .name
*       .fullName
*       .personalInfo
*         .age
*         .dob
*       .password
*
*
*
* IMPORTANT NOTE:
* Altough this parser follows the general rules for JSON strings as
* described in JSON.org, and because of that it should work for 
* deserializing any JSON-compatible string, the main goal for this
* library is to be used with Foxpro objects. 
*
* DON'T TAKE FOR GRANTED THAT THIS LIBRARY WILL WORK WITH JSON
* STRINGS GENERATED BY OTHER JSON PARSERS, NOR THE JSON STRING
* GENERATED BY THIS LIBRARY SHOULD WORK WITH OTHER JSON PARSERS.
*
* Altough this library should work with any kind of object, it
* contains an special class called JSONObject wich is very
* light (based on EMPTY class) and can be used to create and recreate
* JSON-compatible objects. In most cases, we recomend to use JSONObject
* to represent data objects instead your own clases, unless they are
* base on the EMPTY class.
*
* NOTE ON ARRAY VALUES AND COLLECTION OBJECTS
* JSONEncode will accept array-type values or properties but, take on
* consideration that JSONDecode will parse this arrays values as 
* Collections. In the same way, object properties that are based on
* Collection class will be encoded as array values.
*
#DEFINE CRLF	CHR(13) + CHR(10)

LOCAL o
o = CREATEOBJECT("Empty")
ADDPROPERTY(o,"Test","Victor Espina")
ADDPROPERTY(o,"DaysOfWeek",CREATEOBJECT("Collection"))
o.daysOfWeek.Add("Lunes")
o.daysOfWeek.Add("Martes")

LOCAL x
x = CREATEOBJECT("Empty")
ADDPROPERTY(x,"Day","Miercoles")

o.daysOfWeek.Add(x)

cJSON = JSONEncode(o)
?cJSON

RELEASE o

o = JSONDecode(cJSON)
?o.daysOfWeek.Item(1)
?o.daysOfWeek.Item(3).Day

RETURN


* JSONEncode
* Takes an object reference and returns a JSON representation 
*
PROCEDURE JSONEncode(poObj)
 *
 LOCAL aProps[1]
 LOCAL nCount, i, cJSON, cProp, lIsArray
 nCount = AMEMBERS(aProps,poObj,1)   && Get member list
 cJSON = "{"
 FOR i = 1 TO nCount   && Cycle trough members
  *
  DO CASE
     CASE aProps[i,2] = "Property"    && Just process property members
          cProp = aProps[i,1]
          lIsArray = (TYPE("poObj." + cProp,1) = "A")
          * Encode the property and add it to the JSON chain
          IF NOT lISArray
           cJSON = cJSON + IIF(i > 1,",","") + LOWER(cProp) + ":" + ALLTRIM(JSONEncodeValue(poObj.&cProp))
          ELSE
           LOCAL ARRAY aValues[1]
           ACOPY(poObj.&cProp, aValues)
           cJSON = cJSON + IIF(i > 1,",","") + LOWER(cProp) + ":" + JSONEncodeValue(@aValues)
          ENDIF
  ENDCASE
  *
 ENDFOR
 cJSON = cJSON + "}"
 
 RETURN cJSON
 *
ENDPROC



* JSONDecode
* Takes a JSON string and recreates the original object. If pcJSON is an array this function
* will return a Collection instance with the array contents.
*
PROCEDURE JSONDecode(pcJSON)
 *
 LOCAL oObjects, i, oResult, lIsArray
 IF LEFT(pcJSON,1) = "["
  lIsArray = .T.
  oResult = CREATEOBJECT("Collection")
 ELSE
  lIsArray = .F.
  oResult = CREATEOBJECT("Empty")
 ENDIF
 pcJSON = SUBSTR(pcJSON,2,LEN(pcJSON) - 2) 
 
 LOCAL oPairs, j, cPair, cProp, cValue, uValue, oObj, cObj, nBlockCount, nSep
 oObjects = JSONSplit(pcJSON)
 FOR i = 1 TO oObjects.Count
  *
  cObj = oObjects.Item[i]
  
  IF lIsArray AND JSONIsObject(cObj)
   oResult.Add(JSONDecode(cObj))
   LOOP
  ENDIF

  oPairs = JSONSplit(cObj)
  oObj = CREATEOBJECT("Empty")
  FOR j = 1 TO oPairs.Count
   *
   cPair = ALLTRIM(oPairs.Item[j])
   IF lIsArray
    cValue = cPair
   ELSE
    nSep = AT(":",cPair)
    cProp = LEFT(cPair, nSep - 1)
    cValue = SUBSTR(cPair, nSep + 1) 
   ENDIF
   
   DO CASE
      CASE LEFT(cValue,1) = [']    && String value
           uValue = LEFT(SUBSTR(cValue,2),LEN(cValue) - 2)
           
      CASE LEFT(cValue,1) = [@]   && Date/DateTime
           cValue = SUBSTR(cValue,2)
           IF LEN(cValue) = 8
            uValue = CTOD(TRANSFORM(cValue,"@R ^9999-99-99"))
           ELSE
            uValue = CTOT(TRANSFORM(cValue,"@R ^9999-99-99 99:99:99"))
           ENDIF
      
      CASE INLIST(cValue,"true","false")  && Boolean value
           uValue = (cValue == "true")
           
      CASE LEFT(cValue,1) = [{]   && Object
           uValue = JSONDecode(cValue)
           
      CASE LEFT(cValue,1) = "["   && Array
           uValue = JSONDecode(cValue)
 
      CASE INLIST(LOWER(cValue),"string","numeric","date","datetime","boolean","array")  && Schema
           DO CASE
              CASE cValue == "string"
                   uValue = ""
                   
              CASE cValue == "numeric"
                   uValue = 0.0
                   
              CASE cValue == "date"
                   uValue = {}
                   
              CASE cValue == "datetime"
                   uValue = {//::}
                   
              CASE cValue == "boolean"
                   uValue = .F.
                   
              CASE cValue == "array"
                   uValue = CREATEOBJECT("Collection")
           ENDCASE
           
      OTHERWISE                   && Numeric value
           uValue = VAL(cValue)
   ENDCASE

   IF lIsArray
    oResult.Add(uValue)
   ELSE
    *try
    	ADDPROPERTY(oResult,cProp,uValue)
   * CATCH TO oError
       *stop()
       
    *ENDTRY 
   ENDIF
   *
  ENDFOR
  
  *
 ENDFOR
 
 RETURN oResult
 *
ENDPROC



* JSONObject
* Helper class to create JSON-friendly objects
*
DEFINE CLASS JSONObject AS Custom
 *
 Buff = NULL
 Schema = ""
 
 * Class constructor. If a JSON string is passed, it recreate
 * the object from it automatically
 PROCEDURE Init(pcJSON)
  THIS.Buff = CREATEOBJECT("Empty")
  IF VARTYPE(pcJSON) = "C"
   IF LEFT(pcJSON,7) == "schema:"
    LOCAL cSchema
    cSchema = LOWER(SUBSTR(pcJSON,8))
    IF JSONSchemas.getKey(cSchema) > 0
     THIS.parseFromSchema(cSchema)
    ELSE
      THROW "qdfoxJSON: Schema " + cSchema + " has not been declared"
    ENDIF
   ELSE 
    THIS.Parse(pcJSON)
   ENDIF
  ENDIF
 ENDPROC
 
 
 * THIS Accessor
 * Returns the appropiate reference base on the requested member
 PROCEDURE THIS_Access(cMember)
  IF LOWER(cMember)<>"buff" AND PEMSTATUS(THIS.Buff, cMember, 5)
   RETURN THIS.Buff
  ELSE
   RETURN THIS
  ENDIF
 ENDPROC

 
 * Add
 * Add a new property to the object
 PROCEDURE Add(pcProp, puValue1)
  DO CASE
     CASE TYPE("puValue1",1) = "A"
          LOCAL oArray,i
          oArray = THIS.addArray(pcProp)
          FOR i = 1 TO ALEN(puValue1,1)
           oArray.Add(puValue1[i,1])
          ENDFOR
          RETURN oArray
     
     CASE JSONIsObject(puValue1)
          ADDPROPERTY(THIS.Buff,pcProp,JSONObject(puValue1))
          RETURN THIS.Buff.&pcProp
     
     OTHERWISE
          ADDPROPERTY(THIS.Buff, pcProp, puValue1)
  ENDCASE
 ENDPROC
 
 * addArray
 * Add a new array property to the object
 PROCEDURE addArray(pcProp, pcValues)
  IF VARTYPE(pcValues) <> "C"
   ADDPROPERTY(THIS.Buff, pcProp, CREATEOBJECT("Collection"))
  ELSE
   ADDPROPERTY(THIS.Buff, pcProp, JSONDecode("[" + pcValues + "]"))
  ENDIF
  RETURN THIS.Buff.&pcProp
 ENDPROC
 
 * ToJSON
 * Return a JSON string representing the object data
 PROCEDURE ToJSON
  RETURN JSONEncode(THIS.Buff)
 ENDPROC
 
 * Parse
 * Take a JSON string and recover the object data from it
 PROCEDURE Parse(pcJSON)
  THIS.Buff = JSONDecode(pcJSON)
 ENDPROC
 
 * parseFromSchema
 * Create and empty object from a declared schema
 PROCEDURE parseFromSchema(pcSchema)
  pcSchema = LOWER(pcSchema)
  THIS.Buff = JSONDecode( JSONSchemas.Item[pcSchema] )
  THIS.Schema = pcSchema
 ENDPROC
 
 * Import
 * Import object's properties from an object or alias
 PROCEDURE Import(puSource)
  DO CASE
     CASE VARTYPE(puSource) = "O"  && Object
          LOCAL ARRAY aProps[1]
          LOCAL nCount, i, cProp
          nCount = AMEMBERS(puSource,0)
          FOR i = 1 TO nCount
           cProp = aProps[i]
           IF PEMSTATUS(THIS.Buff,cProp,5)
            STORE EVALUATE("puSource." + cProp) TO ("THIS.Buff." + cProp)
           ENDIF
          ENDFOR
     
     CASE VARTYPE(puSource) = "C" AND USED(puSource) && Alias
          LOCAL i,cProp
          FOR i = 1 TO FCOUNT(puSource)
           cProp = FIELD(i, puSource)
           IF PEMSTATUS(THIS.Buff,cProp,5)
            STORE EVALUATE("puSource." + cProp) TO ("THIS.Buff." + cProp)
           ENDIF
          ENDFOR
  ENDCASE
 ENDPROC
 
 
 * Export
 * Export object's properties value to a given object or alias
 PROCEDURE Export(puTarget)
  DO CASE
     CASE VARTYPE(puTarget) = "O"  && Object
          LOCAL ARRAY aProps[1]
          LOCAL nCount, i, cProp
          nCount = AMEMBERS(puTarget,0)
          FOR i = 1 TO nCount
           cProp = aProps[i]
           IF PEMSTATUS(THIS.Buff,cProp,5)
            STORE EVALUATE("THIS.Buff." + cProp) TO ("puTarget." + cProp)
           ENDIF
          ENDFOR
     
     CASE VARTYPE(puTarget) = "C" AND USED(puTarget) && Alias
          LOCAL i,cProp
          SELECT (puTarget)
          FOR i = 1 TO FCOUNT()
           cProp = FIELD(i)
           IF PEMSTATUS(THIS.Buff,cProp,5)
            REPLACE (cProp) WITH EVALUATE("THIS.Buff." + cProp)
           ENDIF
          ENDFOR
  ENDCASE
 ENDPROC
 
 *
ENDDEFINE


* JSONObject
* Quick function to create empty JSON-friendly objects
*
* Usage:
* o = JSONObject()             && Empty object
* o = JSONObject(cMyJSONStr)   && Recreates a object
*
PROCEDURE JSONObject(pcJSON)
 RETURN CREATEOBJECT("JSONObject",pcJSON)
ENDPROC


* JSONDeclareSchema
* Declares a public object schema
*
PROCEDURE JSONDeclareSchema(pcNAme, pcSchema)
 *
 IF PCOUNT() <> 2
  THROW "qdfoxJSON: JSONDeclareSchema: invalid parameter count"
  RETURN NULL
 ENDIF
 
 IF VARTYPE(JSONSchemas) = "U"
  PUBLIC JSONSchemas
  JSONSchemas = CREATEOBJECT("Collection")
 ENDIF
 
 JSONSchemas.Add( pcSchema, LOWER(pcName) )
 *
ENDPROC


*****************************************************
**
**     S U P P O R T    F U N C T I O N S
**
*****************************************************

* JSONEncodeValue
* Internal funcion for JSON encoding. Do not use directly
*
PROCEDURE JSONEncodeValue(puValue2)
  *
  LOCAL lIsArray, cType, cJSONValue
  lIsArray = (TYPE("puValue2",1) = "A")
  cType = VARTYPE(puValue2)
  cJSONValue = "null"
  DO CASE
     CASE lIsArray        && Array value
          cJSONValue = "["
          LOCAL i
          FOR i = 1 TO ALEN(puValue2,1)
           cJSONValue = cJSONValue + IIF(i>1,",","") + JSONEncodeValue(puValue2[i])
          ENDFOR
          cJSONValue = cJSONValue + "]"
     
     CASE cType $ "CM"    && string/char value
          cJSONValue = ['] + puValue2 + [']
          
     CASE cType $ "NIYF"   && Numeric value
          IF puValue2 = INT(puValue2)
           cJSONValue = ALLTRIM(STR(puValue2))
          ELSE
           cJSONValue = ALLTRIM(STR(puValue2,10))
          ENDIF
          
     CASE cType = "L"     && boolean value
          cJSONValue = IIF(puValue2,"true","false")
          
     CASE cType = "D"     && Date value (foxpro only)
          cJSONValue = [@] + DTOS(puValue2)
          
     CASE cType = "T"     && Datetime value (foxpro only)
          cJSONValue = [@] + TTOC(puValue2,1)
          
     CASE cType = "O"     && Object value
          DO CASE
             CASE JSONIsCollection(puValue2)
		          LOCAL ARRAY aItems[puValue2.Count]
		          LOCAL i
		          FOR i = 1 TO puValue2.Count
		           aItems[i] = puValue2.Item[i]
		          ENDFOR
		          cJSONValue = JSONEncodeValue(@aItems)
		          RELEASE aItems
             
             CASE PEMSTATUS(puValue2,"ToJSON",5)
                  cJSONValue = puValue2.toJSON()

             OTHERWISE
		          cJSONValue = JSONEncode(puValue2)             
          ENDCASE
          
     OTHERWISE            && unknown type. Handle it as a string value
          cJSONValue = TRANSFORM(puValue2,"")
  ENDCASE

  RETURN cJSONValue
  *
ENDPROC


* JSONSplit
* Take a JSON string and return a list of defined objects
*
PROCEDURE JSONSplit(pcJSON)
 *
 LOCAL nBlockCount,cObj
 nBlockCount = 0  
 cObj = pcJSON
 FOR j = 1 TO LEN(cObj)
   DO CASE
      CASE SUBSTR(cObj,j,1) $ "[{"
           nBlockCount = nBlockCount + 1
   
      CASE SUBSTR(cObj,j,1) $ "]}"
           nBlockCount = nBLockCount - 1
           
      CASE SUBSTR(cObj,j,1) = "," AND nBlockCount = 0
           cObj = STUFF(cObj,j,1,CHR(254))
   ENDCASE
 ENDFOR   
 
 LOCAL ARRAY aObjects[1]
 LOCAL nCount, i, oResult
 oResult = CREATEOBJECT("Collection")
 nCount = ALINES(aObjects, STRT(cObj,CHR(254),CRLF))
 FOR i = 1 TO nCount
  oResult.add(aObjects[i])
 ENDFOR
 
 RETURN oResult
 *
ENDPROC


* JSONIsCollection
* Internal funcion. Does not use directly
*
PROCEDURE JSONIsCollection(poObj)
 RETURN PEMSTATUS(poObj,"Count",5) AND PEMSTATUS(poObj,"Item",5)
ENDPROC


* JSONIsObject
* Internal function.Does not use directly
*
PROCEDURE JSONIsObject(pcString)
 RETURN VARTYPE(pcString)="C" AND LEFT(pcString,1)="{" AND RIGHT(pcString,1)="}"
ENDPROC


